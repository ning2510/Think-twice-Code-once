#### LeetCode 1014. 最佳观光组合

首先看一眼数据后排除 O(n^2) 的做法

则考虑 O(n) 的做法

我们发现每个观光点只和它后面的观光点组合，则考虑逆序枚举，先处理好后面景点则更方便处理前面的景点 (当然正序枚举也是可以的)

在枚举的同时我们记录好后面每个景点的 `A[j] - j` 的最大值

首先考虑用优先队列 (ss) 实时排序，枚举每个景点后将每个景点进行计算后入队

当枚举第 i 个景点时我们得到的最大值即为：`A[i] + i - ss.top()`

此时时间复杂度变为 O(n)

接下来看是否可优化空间复杂度

当我们枚举到第 i 个景点时，我们只需知道第 i 个景点之后景点的最大值

故我们可以在枚举之后更新最大值，即用 O(1) 的空间去代替优先队列



**代码实现：**

```c++
class Solution {
public:
    int maxScoreSightseeingPair(vector<int>& A) {
        int ans = -1005, n = A.size() - 1, mx = A[n] - n;
        for(int i = n - 1; i >= 0; i--) {
            ans = max(ans, A[i] + i + mx);
            mx = max(mx, A[i] - i);
        }
        return ans;
    }
};
```

